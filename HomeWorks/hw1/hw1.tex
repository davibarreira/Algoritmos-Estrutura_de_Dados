\documentclass{article}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{fullpage}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{url}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{enumitem}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{amsthm}
\renewcommand*{\proofname}{Prova}


\DeclarePairedDelimiter\ceil{\lceil}{\rceil}


\parindent0in
\pagestyle{plain}
\thispagestyle{plain}
\setlength{\parskip}{1em}

\newcommand{\assignment}{Homework 1}
\newcommand{\duedate}{July 21, 2019}

% \renewcommand\thesubsection{\arabic{subsection}}

\title{Homework 1}
\date{20/07/2019}

\begin{document}

Fundação Getulio Vargas\hfill\\
Estruturas de Dados e Algoritmos\hfill\textbf{\assignment}\\
Prof.\ Jorge Poco\hfill\textbf{Due}: \duedate\\
Aluno: Davi Sales Barreira
\smallskip\hrule\bigskip

{\let\newpage\relax\maketitle}
\maketitle


\section{Induction [3pts]}
Answers should be written in this document. 

\begin{enumerate}
  \item Prove by Induction that:
  \( \sum_{i=1}^{n}i^2=\frac{n(n+1)(2n+1)}{6} \qquad\forall n \geq 0\)

  \item Prove by Induction that:
  $\forall n \geq 7$ it is true $3^n<n!$
  
  \item Prove by Induction that $\forall n \geq 0$
  \[
    \left \lceil\frac{n}{2} \right \rceil=
    \left\{
    \begin{array}{ll}
    \frac{n}{2}& \textrm{si $n$ es par}\\
    \frac{n+1}{2}& \textrm{si $n$ es impar}
    \end{array}
    \right.
  \]
  
    \item Prove by induction that a number is divisible by 3 if and only if the sum of its digits is divisible by 3.
    
    \item Prove that any integer greater than 59 can be formed using only 7 and 11 cent coins.
  
  \item Prove by induction that $F_{n+k}=F_{k}F_{n+1}+F_{k-1}F_{n}$
  
  \item Prove by induction in $n$ that \(\sum_{m=0}^{n}{n \choose m}=2^n\)
  
  \item Prove by induction that a graph with $n$ vertices can have at most  $\frac{n(n-1)}{2}$ edges.
  
  \item Prove by induction that a complete binary tree\footnote{http://web.cecs.pdx.edu/~sheard/course/Cs163/Doc/FullvsComplete.html} with $n$ levels has $2^n-1$ vertices.
  
  \item A polygon is convex if each pair of points in the polygon can be joined by a straight line that does not leave the polygon. Prove by induction in $n>3$ that the sum of the angles of a polygon of $n$ vertices is $180(n-2)$.
  
\end{enumerate}

\section{Correctness of bubblesort [2pts]}
Bubblesort is a popular, but inefficient, sorting algorithm. It works by repeatedly swapping adjacent elements that are out of order.

\begin{algorithm}[H]
\SetAlgoLined
  \For{$i = 1$ \textbf{to} $A.length -1$} {
    \For{$j = A.length$ \textbf{downto} $i + 1$} {
      \If{$A[j] < A[j-1]$} {
        exchange $A[j]$ with $A[j-1]$
      }
    }
  }
\caption{BUBBLESORT(A)}
\end{algorithm}

\begin{enumerate}[label=\Alph*]
  \item Let $A'$ denote the output of BUBBLESORT(A). To prove that BUBBLESORT is correct, we need to prove that it terminates and that
  
  \begin{equation} \label{eq:1}
    A'[1] \leq A'[2] \leq ... \leq A'[n]
  \end{equation}
  
  where $n = A.length$. In order to show that BUBBLESORT actually sorts, what else do we need to prove?
  
  The next two parts will prove inequality~(\ref{eq:1}).
  
  \item State precisely a loop invariant for the \textbf{for} loop in lines 2–6, and prove that this loop invariant holds. Your proof should use the structure of the loop invariant proof presented in this chapter.
  
  \item Using the termination condition of the loop invariant proved in part (B), state a loop invariant for the for loop in lines 1–7 that will allow you to prove inequality~(\ref{eq:1}). Your proof should use the structure of the loop invariant proof presented in this chapter.
  
  \item What is the worst-case running time of BUBBLESORT? How does it compare to the running time of insertion sort?
\end{enumerate}


\section{Growth of Functions [2pts]}

\begin{enumerate}[label=\Alph*]
  \item For each of the following pairs of functions, either $f(n)$ is in $O(g(n))$, $f(n)$ is in $\Omega(g(n))$, or $f(n) = \Theta(g(n))$. Determine which relationship is correct and briefly explain why.
    \begin{itemize}
      \item $f(n) = \log n^2$; $g(n) = \log n + 5$
      \item $f(n) = \log^2 n$; $g(n) = \log n$
      \item $f(n) = n\log n + n$; $g(n) = \log n$
      \item $f(n) = 2^n$; $g(n) = 10n^2$
    \end{itemize}
  
  \item Prove that $n^3 -3n^2 -n+1 = \Theta(n^3)$.
  \item Prove that $n^2 = O(2^n)$.
  
\end{enumerate}


\section{Insertion Sort - Mergesort - Quicksort [3pts]}
Implement the insertion sort, merge sort and quicksort using the template \texttt{test.py} (use Python 3.X). Create a \texttt{test.cpp} file and write the equivalent code from \texttt{test.py} in C++, ie., the functions: main, \texttt{insertion\_sort}, \texttt{merge\_sort}, \texttt{quicksort} and \texttt{is\_sorted}. For the random number generations you can use the \texttt{rand} function from \texttt{cstdlib}\footnote{\url{http://www.cplusplus.com/reference/cstdlib/rand/}}. Your code should print the tuple (number of objects, time insertion\_sort, time merge\_sort, time quicksort)

You must submit both \texttt{test.py} and \texttt{test.cpp}. Graphs and descriptions must be included in this document. 

\subsection{Random Order}
\begin{enumerate}
  \item Create 10 sets of numbers in random order. The sets must have \{10k, 20k, 30k, ..., 100k\} numbers.
  
  \item Sort these numbers using the 3 algorithms and calculate the time each algorithm takes for each set of numbers.
  
  \item Generate a plot (using excel or another tool) showing a \emph{linechart}, where the $x$-axis is the ``number of elements", and the $y$-axis is the time that the algorithms took in C++ and Python. This plot must have 6 lines of different colors with a legend.
  
  \item Write a small paragraph (3 to 4 lines) describing the results.

\end{enumerate}

\subsection{Ascending Order}
Do the same experiment when the numbers are ordered in ascending order.

\subsection{Descending Order}
Do the same experiment when the numbers are ordered in descending order.

\pagebreak
\part*{Respostas}

\section*{Questão 1}
\subsection*{1.1}
\begin{proof}
$ $\newline
Caso Base: $n = 1$, temos $\sum^{n}_{i=1}{i^2}= \frac{1\cdot2\cdot3}{6}=1 \therefore$ Satisfeito para $n = 1$.

Hipótese indutiva: Supondo que $\sum^{n}_{i=1}{i^2} =\frac{n(n+1)(2n+1)}{6}$, para $n = k$.

Passo de indução: Seja $n = k + 1$
$$\sum^{k+1}_{i=1}{i^2} = (k+1)^2 + \frac{k(k+1)(2k+1)}{6} =
\frac{(k+1)(6(k+1) + k(2k + 1))}{6} = \frac{(k+1)(k+2)(2k +3)}{6} 
$$
$$
\sum^{k+1}_{i=1}{i^2} = \frac{(k+1)(k+1+1))(2(k+1)+1)}{6}
$$
\end{proof}

\subsection*{1.2}
\begin{proof}
$ $\newline
Caso Base: $n = 7$, temos $n! = 7! = 5040$ e $3^7 = 2187 \therefore$ Satisfeito para $n = 7$.

Hipótese indutiva: Supondo que para $n=k, 3^k < k!$

Passo de indução: Seja $n = k + 1$, $3^k < k!$
, note que como $k>3$, temos que $k+1>3$

$\therefore 3^{k+1}=3^k\cdot3 < k!\cdot(k+1)=(k+1)!$

\end{proof}

\subsection*{1.3}
\begin{proof}
$ $\newline
  \[Prop:
    \left \lceil\frac{n}{2} \right \rceil=
    \left\{
    \begin{array}{ll}
    \frac{n}{2}& \textrm{se $n$ é par}\\
    \frac{n+1}{2}& \textrm{se $n$ é impar}
    \end{array}
    \right.
  \]
Caso Base: 

$n=0,\lceil\frac{0}{2}\rceil=0=\frac{n}{2}\therefore$ satisfeito para $n=0$

$n=1,\lceil\frac{1}{2}\rceil=1=\frac{1+1}{2}\therefore$ satisfeito para $n=1$

Hipótese indutiva: Supondo que para $n=k$ vale a proposição.

Passo de indução: Se $k$ for par, então $\lceil\frac{k}{2} \rceil = \frac{k}{2}$, assim
$k+1$ é ímpar, logo
$$
\ceil*{\frac{n+1}{2}} = \ceil*{\frac{k}{2}} + \ceil*{\frac{1}{2}} =\frac{k}{2}+1 = \frac{(k+1)+1}{2}
$$
Se k for ímpar, $\ceil*{\frac{k}{2}} = \frac{k+1}{2}$, assim $k+1$ é par, logo
$$\ceil*{\frac{k+1}{2}}=\frac{k+1}{2}$$
\end{proof}


\subsection*{1.4}
\begin{proof}
Vamos provar que o resto da divisão de um número por 3 é igual ao resto da divisão da soma
dos seus dígitos, ou seja, em $P_n$ temos que $\overline{a_1a_2...a_n} \mod 3 = \sum_{i=1}^n{a_i} \mod 3$

Caso Base: Para $P_1$ temos os número com 1 dígito, portanto a condição é satisfeita trivialmente já
a soma dos dígitos é igual ao próprio número.

Hipótese indutiva: Supondo que $P_n$ é válida.

Passo de indução: Analisando $P_{n+1}$, temos então A = $\overline{a_1...a_na_{n+1}} = \overline{a_1...a_n}+10*a_{n+1}$:
$$A \mod 3 = \overline{a_1...a_{n+1}} \mod 3$$
$$A \mod 3 = \overline{a_0...a_n} + 10a_{n+1} \mod 3$$
$$A \mod 3 = \overline{a_0...a_n} + a_{n+1} +9a_{n+1} \mod 3$$
Como $9a_{n+1} \mod 3 = 0$, então, utilizando a propriedade $P_n$, temos que:
$$A \mod 3 = \overline{a_0...a_n} + a_{n+1} \mod 3 = a_0 + ... + a_n + a_{n+1} \mod 3$$
\end{proof}


\subsection*{1.5}
\begin{proof}
$ $\newline
Caso Base: $n = 60 = 7\cdot7 + 11\cdot1 \therefore$ Satisfeito. 

Hipótese indutiva: Supondo que para $n=k = a\cdot7 + b\cdot11$, onde $a,b \in \mathbb{N}\cup\{0\}$

Passo de indução: Para $n = k+1$, temos que $k+1 =a\cdot7 + b\cdot11 + 1$

Utilizaremos o fato de que $2\cdot11-3\cdot7 = 1$  e  $8\cdot7 - 5\cdot11 = 1$

\begin{itemize}

\item Se $a \geq  3 \therefore k + 1 =a\cdot7+b\cdot11+2\cdot11-3\cdot7 = (a-3)\cdot7 + (b+2)\cdot11$. Portanto,
a proposição vale quando $a \geq 3 $.

\item Se $a<3$, ou seja $a \in \{0,1,2\}$. Além disso, como $n > 59$ e $a\cdot7 + b\cdot11 > 59 \implies b > 4$, já que $a$ é no máximo 2.
Logo, podemos fazer:
$$k+1 =a\cdot7+b\cdot11+8\cdot11-3\cdot7 = (a+8)\cdot7 + (b-5)\cdot11 $$

\end{itemize}
\end{proof}

\subsection*{1.6}
\begin{proof}
$ $\newline
$F = Fibonacci \therefore F_3 = F_2 + F_1$, além disso, $F_1,F_2 = 1$

Caso Base:
\begin{itemize}
\item Para $n=1$, $F_{1+k}=F_k\cdot F_2+F_1\cdot F_{k-1}=F_k\cdot1+1\cdot F_{k-1} = F_{k+1} \therefore$ Satisfeito.

\item Para $n=2$, $F_{2+k}=F_k\cdot F_3+F_2\cdot F_{k-1}=F_k\cdot2+1\cdot F_{k-1} = F_k + F_k + F_{k-1} = F_k + F_{k+1} =F_{k+2} \therefore$ Satisfeito.
\end{itemize}

Hipótese indutiva: Supondo que $F_{n+k} = F_k \cdot F_{n+1} + F_{k-1} \cdot F_n$ e que $F_{n+k-1} = F_k \cdot F_{n} + F_{k-1} \cdot F_{n-1}$

Passo de indução: Sabemos que na sequência de Fibonacci $F{n+1+k} = F_{n+k} + F_{n-1+k}$, portanto,
$$F_{n+1+k} = F_k \cdot F_{n+1} + F_{k-1} \cdot F_n + F_k \cdot F_{n} + F_{k-1} \cdot F_{n-1}$$
$$F_{n+1+k} = F_k(F_{n+1}+F_{n})+F_{k-1}(F_n + F_{n-1}) = F_k\cdot F_{n+2}+F_{k-1}\cdot F_{n+1}$$

\end{proof}

\subsection*{1.7}
\begin{proof}
$ $\newline
Caso Base: $n = 1,\sum^1_{m=0}{n\choose m}={1\choose 0}+{0\choose 0}=2^1 \therefore$ Satisfeito.

Hipótese indutiva: Supondo que para $n=\sum^1_{m=0}{k\choose m}=2^k$

Passo de indução: Seja $n = k + 1$, utilizaremos a seguinte identidade ${k+1\choose m} = {k\choose m}+{k \choose m-1}$.
$$2\cdot \sum^k_{m=0}{k\choose m} = \bigg[\underbrace{{k\choose 0}}_{k+1\choose0}  + \underbrace{{k\choose 0}+{k\choose 1}}_{k+1\choose 1}
+{k\choose 1}+{k \choose 2}+...+
\underbrace{{k\choose k-1}+{k\choose k}}_{k+1\choose k}+\underbrace{{k\choose k}}_{k+1\choose k+1}\bigg]$$
$$2\cdot 2^k = \bigg[{k+1\choose0}+{k+1\choose1}+...+{k+1\choose k+1}\bigg] = \sum^{k+1}_{m=0}{k+1\choose m}$$

\end{proof}

\subsection*{1.8}
\begin{proof}
$ $\newline
Caso Base: $n = 1$, temos 0 arestas, portanto, $\frac{n(n-1)}{2} = 0 \therefore$ Satisfeito.

Hipótese indutiva: Supondo que para $n=k$, temos um número máximo de arestas igual a $\frac{k(k-1)}{2}$

Passo de indução: Adicionando um novo vértice, temos que ele pode formar arestas com os demais k
vértices, logo o total de arestas aumenta em $k$, ou seja, temos $\frac{k(k-1)}{2}+k$ arestas.

Portanto, número de arestas para $k+1$ vértices é igual à 
$$\frac{k(k-1)}{2}+k = \frac{k(k-1 + 2)}{2} = \frac{(k+1)(k+1 -1)}{2}$$

\end{proof}

\subsection*{1.9}
\begin{proof}
$ $\newline
Caso Base: $n = 1$ temos que $2^1 - 1 = 1 \therefore$ Satisfeito.

Hipótese indutiva: Supondo que para $n = k$ camadas temos $2^k -1$ vértices.

Passo de indução: Adicionando uma nova camada às $k$ existentes, ficamos com a estrutura ilustrada abaixo.
  \begin{figure}[!h]
  \centering
  \includegraphics[height=3cm]{Q1_9.png}
  \end{figure}


Assim, para $k$ camadas a quantidade de vértices era $2^k -1$, e ao adicionar uma nova camada temos
$2(2^k - 1)+1$ vértices, como pode ser observado na figura acima. Portanto, para $k+1$ camadas, temos
que a quantidade de vértices é $2^{k+1} - 1$.

\end{proof}

\subsection*{1.10}
\begin{proof}
$ $\newline
Caso Base: $n =4$, temos pela definição de polígonos convexoes que podemos traçar uma linha entra dois
vértices sem que saia do polígono. Portanto, podemos formar dois triângulo. Como seus ângulos somam 180
cada, temos assim que a soma dos ângulos internos é igual à $180\cdot 2 = 180(4-2)$

Hipótese indutiva: Supondo que a propriedade é válida para polígonos de $n=k$ vértices.

Passo de indução: Tome um polígono convexo de $k$ vértices. Um polígono convexo de $k+1$ vértices pode ser
formado adicionando um novo vértice fora do polígono original.
  \begin{figure}[!h]
  \centering
  \includegraphics[height=3cm]{Q1_10.png}
  \end{figure}

Portanto, a soma dos ângulos internos será dada por $180(k-2)+180 = 180(k+1 -2)$, como queríamos demonstrar.
\end{proof}

\section*{Questão 2}
\subsection*{2.A}
Se sabemos que $A' = BUBBLESORT(A)$, tal que $A'[0]\leq...\leq A'[n]$, onde $n=A.length$. Então, o algoritmo
termina com seus elementos ordenados. A única coisa que basta garantir é que os elementos de A' são os 
mesmos elementos de A. Com isso, A' será A ordenado e o algoritmo é eficaz.
\subsection*{2.B}
Primeiro, faça $n = A.length$

Assim, o invariante é que no início de cada loop o menor elemento de $A[i,..,n]$ estará no
máximo na posição $j$.

Para o primeiro loop (inicialização), $j=n$, logo o invariante é trivialmente satisfeito, já que o menor
elemento de $A[i,...,n]$ está em no máximo na posição $n$. Vamos mostrar que esse invariante se mantém.

Suponha que o menor elemento está no máximo na posição $j=k$. Assim, se o menor elemento estiver em $A[k]$, então
$A[k]<A[k-1]$, e trocamos os elementos de posição, tal que sabemos que o menor elemento de $A[i,...,n]$ vai estar
no máximo na posição $k-1$. Se $A[k]$ não é o menor elemento, então o menor elemento já estava no máximo na posição
$k-1$ e o loop não faz nada. Assim, provamos que o invariante se mantém nas duas condições.

No término, temos que $j=i+1$, então, garantimos que o menor elemento está no máximo na posição $i$.
\subsection*{2.C}
Para o loop externo, o invariante é que no início de cada loop, $A[1,...i-1]$ contém os menores $i-1$ elementos
e está ordenado.

Na inicialização, temos que $i=1$, assim, $A[i-1]=A[0]$ e, portanto, o invariante é verdadeiro por vacuidade.

Supondo que para $i=k$, no início do loop, o vetor $A[j,...,k-1]$ está ordenado com os menores $k-1$ valores de A.
Pelo item "B", sabemos que ao final do loop interno (linhas 2 a 6), o menor elemento de $A[k,...n]$ vai estar na posição $k$.
Portanto, ao final dessa iteração, $A[1,...,k]$ vai estar ordenado, já que $A[k]\geq A[k-1]$ pelo loop interno, e 
$A[1]\leq...\leq A[k-1]$ por hipótese. Logo, provamos que o invariante se mantém.

No término, temos que $i=n+1$, logo $A[1,...,n]$ vai estar ordenado, concluindo nossa prova.

\subsection*{2.D}
Note que o algoritmo do BUBBLESORT sempre realiza $n-1$ iterações para o loop exterior e $n-i$ iterações
para o loop interior, onde $i$ é a iteração do loop exterior. Logo, o total de iterações é dado por
$(n-1)+(n-2)+...+1 = n(n-1)/2$. Assim, temos $\Theta(n^2)$ para o melhor e
para o pior caso. Comparado ao {\it Insertion Sort}, o BUBBLESORT tem um pior desempenho, já que o pior caso
do {\it Insertion Sort} também é $\Theta(n^2)$, porém, seu melhor caso é $\Theta(n)$.

\section*{Questão 3}
Iremos utilizar as seguintes definições:
\begin{itemize}
      \item $ f(n)=O(g(n))\iff \exists n_o \in \mathbb{N}$, e $\exists c_1 \in \mathbb{R}_+$ tal que $\forall n\geq n_o \implies f(n) \leq c_1 \cdot g(n)$
      \item $ f(n)=\Omega(g(n))\iff\exists n_o \in \mathbb{N}$, e $\exists c_2 \in \mathbb{R}_+$ tal que $\forall n\geq n_o \implies f(n) \geq  c_2 \cdot g(n)$
      \item $ f(n)=\Theta(g(n))\iff\exists n_o \in \mathbb{N}$, e $\exists c_1,c_2 \in \mathbb{R}_+$ tal que
      $\forall n\geq n_o \implies c_1 \cdot g(n) \geq  f(n) \geq  c_2 \cdot g(n)$
  \end{itemize}

\subsection*{A)}
\begin{itemize}
  \item $f(n) = \Theta(g(n))$;
  \begin{proof}
  $f(n) = \log{n^2} = 2\log{n}$, e $g(n) = \log{n} +5$, assim, para $n_o=2,c_1 = 2,c_2=1/10$, temos que
  $\forall n\geq n_o \implies 1/10\log{n}+5/10 \leq 2\log{n} \leq 4\log{n} + 20 \therefore f(n) = \Theta(g(n))$
  \end{proof}

  \item
  $f(n) = \Omega(g(n))$;
  \begin{proof}
  $f(n) = \log^2{n} = \log{n}\cdot\log{n}$ e $g(n) = \log{n}$. Tomando $c_2=1,n_o = 2$, temos que
  $\forall n \geq  n_o \implies \log^2{n} \geq  \log{n} \therefore f(n) = \Omega(g(n))$, pois não existe $c_1$ e $n_o$
  que satisfaçam a condição do $f(n) = O(g(n))$.
  \end{proof}

  \item
  $f(n) = \Omega(g(n))$;
  \begin{proof}
  $f(n) = n\log{n} + n$ e $g(n) = \log{n}$. Tomando $c_2=2,n_o = 2$, temos que
  $\forall n \geq  n_o \implies n\log{n} + n \geq  \log{n} \therefore f(n) = \Omega(g(n))$, pois não existe $c_1$ e $n_o$
  que satisfaçam a condição do $f(n) = O(g(n))$.
  \end{proof}

  \item
  $f(n) = \Omega(g(n))$;
  \begin{proof}
  $f(n) = 2^n$ e $g(n) =10n^2$. Tomando $c_2=1/10,n_o = 4$, temos que
  $\forall n \geq  n_o \implies 2^n \geq  10n^2/10 \therefore f(n) = \Omega(g(n))$, pois não existe $c_1$ e $n_o$
  que satisfaçam a condição do $f(n) = O(g(n))$.
  \end{proof}
\end{itemize}

\subsection*{B)}
\begin{proof}
$ $\newline
Queremos encontrar $n_o,c_1$ e $c_2$ tal que $\forall n\geq n_o \implies  c_2 \cdot n^3 \leq n^3-3n^2-n+1\leq c_1 \cdot n^3$.

Para isso, basta tomar $n_o = 10, c_1=2, c_2 = 0.5$, assim a desigualdade é satifeita, e portanto $n^3-3n^2-n+1 = \Theta(n^3)$
  % i) Queremos $n^3-3n^2-n+1\leq c_1 \cdot n^3$, $(c_1-1)n^3\geq -3n^2 - n +1$. Para isso, basta tomar  $c_1 = 2, n_o = 1$.
  % Assim, provamos que $n^3-3n^2-n+1 = O(n^3)$.

  % ii) Agora vamos provar que $n^3-3n^2-n+1 = \Omega(n^3)$. Queremos $n^3-3n^2-n+1\geq c_2 \cdot n^3$.
  % Veja que $-3n^2 - n +1 \geq (c_2 -1)n^3$. Assim, tomando $c_2=0.5,n_o =7$, temos que $0.5n^3\geq 3n^2+n-1 \therefore
  % n^3-3n^2-n+1 = \Omega(n^3)$

\end{proof}

\subsection*{C)}
\begin{proof}
$ $\newline
Queremos mostrar que $n^2 = O(2^n)$

Basta tomar $n_o=5,c_1=1$, assim $\forall n\geq n_o$, temos que $n^2\leq 2^n$. Portanto, $n^2 = O(2^n)$

\end{proof}


\section*{Questão 4}

Os gráficos abaixo comparam os resultados obtidos para os diferentes algoritmos de sorting
implementados tanto em C++ como em Python, sendo os gráficos da direita em escala logaritmica para o eixo y.
Como esperado, o código de C++ performa melhor
que em Python, com a diferença maior sendo no algoritmo de {\it insert sort}.

Além disso, observamos que o {\it quicksort} apresentou o melhor
desempenho considerando tanto o vetor com valores aleatórios como o com
valores descendentes.
No vetor já ordenado ({\it ascending}), o tempo dos três algoritmos é muito baixo, como
era de se esperar, porém, nesse caso o {\it insert sort} foi quem apresentou o melhor
resultado.


  \begin{figure}[!h]
  \centering
  \includegraphics[width=0.8\linewidth,height=5cm]{SortTime_Random.png}
    \caption{Comparação de performance dos algoritmos de {\it sorting} para vetores aleatórios}
    \vspace{0.5cm}
  \includegraphics[width=0.8\linewidth,height=5cm]{SortTime_Ascending.png}
    \caption{Comparação de performance dos algoritmos de {\it sorting} para vetores crescentes}
    \vspace{0.5cm}
  \includegraphics[width=0.8\linewidth,height=5cm]{SortTime_Descending.png}
    \caption{Comparação de performance dos algoritmos de {\it sorting} para vetores decrescentes}
  \end{figure}

  % Figure \ref{fig:boat1} shows a boat.




\end{document}